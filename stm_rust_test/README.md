# Blink example for STM32-F411RE

1. Install Rust 
	- Windows: install rust-init.exe from website
	- WSL: `curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh`
2. Update toolchain: `rustup update`
3. Install cargo-flash
	- `cargo install cargo-flash `
4. Install compile target
	- `rustup target add thumbv7em-none-eabihf`
5. Flash board
	- Plug in board
	- `cargo-flash --chip STM32F411RETx --release`
	- Alternatively, `./build_unix` for Linux/WSL or `./build` for Windows
## Explanation

```rust
#![allow(clippy::empty_loop)]
#![no_main]
#![no_std]

use panic_halt as _;
use cortex_m_rt::entry;
use stm32f4xx_hal as hal;

use crate::hal::{pac, prelude::*};

#[entry]
fn main() -> !{
    if let (Some(dp), Some(cp)) = (pac::Peripherals::take(), cortex_m::Peripherals::take(),)
    {
        let gpioa = dp.GPIOA.split();
        let mut led = gpioa.pa5.into_push_pull_output();

        let rcc = dp.RCC.constrain();
        let clocks = rcc.cfgr.sysclk(48.MHz()).freeze();

        let mut delay = cp.SYST.delay(&clocks);

        loop {
            led.set_high();
            delay.delay_ms(1000_u32);
            led.set_low();
            delay.delay_ms(1000_u32);
        }
    }
    loop {}
}
```

First, let's take a quick look at the frontmatter at the beginning of the file. 

```rust
#![allow(clippy::empty_loop)]
#![no_main]
#![no_std]
```
These lines are called *attributes*, which are kind of like little notes to the 
compiler. Specifically, these are *crate attributes*, which apply to the entire 
file. These are denoted by the `!` at the beginning of the attribute. 

Normally, attributes only apply to the thing immediately after the declaration. 

Specifically, these three attributes allow us to structure our program for embedded 
systems. 

The first line `#![allow(clippy::empty_loop)]` is a note to our **linter** `clippy` 
to not create a warning when we have an empty loop. This is required for our *busy loop*,
which is an infinite loop that the program enters on termination. 

The `no_main` attribute tells the Rust compiler that we don't have a main function. We'll
discuss why that is later. 

The `no_std` attribute tells the compiler not to bundle the Rust standard library with our
program. For most use cases, the standard library is very small. However, when we're dealing
with only a few KiB of RAM, we need to save every bit of memory as possible. If we need to
use anything from the `std` library, we'll import it explicitly. 

```rust
use panic_halt as _;
use cortex_m_rt::entry;
use stm32f4xx_hal as hal;

use crate::hal::{pac, prelude::*};
```
These are all of the imports that we need to interact with the microcontroller. 
- `panic_halt`: This crate replaces the panic behavior of the Rust standard library. Normally,
    when a Rust program panics, whether through some error or by using the `panic!()` macro, the 
    program will terminate, unwind all used memory, and print the stack trace to the standard
    output. However, our embedded system doesn't have any environment to return to on a panic
    because we're not using any kind of operating system. Therefore, we need to manually define 
    behavior on panic. `panic_halt` just tells the compiler to enter an infinite empty loop on 
    termination. 
- `cortex_m_rt`: This crate provides the startup code and a minimal runtime for ARM Cortex-M
    microcontrollers. We'll never really have to worry about this, but essentially the crate
    preloads the microcontroller's *vector table* before the program memory, and dispatches
    exceptions and interrupts. This also provides the `#[entry]` attribute, which lets us define
    the entry point of the program in the absence of a `main()` function. 
- `stm32f4xx_hal`: provides the *hardware abstraction layer* for our board. In particular, 
    this provides handles to our hardware peripherals and functions to initialize, read/write, 
    and route our data to the outside world. 
- The last line imports the HAL's `peripheral access crate`, which is a module containing
    handles to the peripherals. This is generated by the `svd2rust` API. It also imports the 
    basic functions of the library with the `prelude::*`. 


```rust
#[entry]
fn main() -> !{
    // some code
}
```
Our so called `main` function isn't implicitly defined to the compiler because of the
`#![no_main]` attribute. The reason we do this is because of an interesting quirk of 
most low-level programming languages: the main function implicitly returns 0. This is 
so called *exit code* that you see at the beginning of a stack trace. 

However, in our embedded system, our main function is supposed to run forever until manual
termination or reset. Therefore, we need to define a custom function as our entry point that
has a return type of `!`, meaning that our function never returns. This is called a *divergent
function*. 

After writing this main function, we have to tell the compiler that we want this funciton as our
*entry point*, or the first bit of code that runs on startup. 

The rest of the program is relatively straightforward. 

```rust
    if let (Some(dp), Some(cp)) = (pac::Peripherals::take(), cortex_m::Peripherals::take(),)
    {
        let gpioa = dp.GPIOA.split();
        let mut led = gpioa.pa5.into_push_pull_output();

        let rcc = dp.RCC.constrain();
        let clocks = rcc.cfgr.sysclk(48.MHz()).freeze();

        let mut delay = cp.SYST.delay(&clocks);

        loop {
            led.set_high();
            delay.delay_ms(1000_u32);
            led.set_low();
            delay.delay_ms(1000_u32);
        }
    }
    loop {}
}
```

```rust
if let (Some(dp), Some(cp)) = (pac::Peripherals::take(), cortex_m::Peripherals::take(),) {
    // some code
}
```

This line uses an interesting bit of Rust syntax sugar: the `if let` statement. 
Let's try to break this down by example: 

In Java, we can match based on type using the instanceof keyword. 

```Java
class Animal { 
    // some code
} 
Animal frog = new Animal();

if (a instanceof Animal) {
    // do some things
} 
```

Rust has a huge emphasis on its rich type system, and a lot of it's common patterns
and control flows revolve around something called *pattern matching*. For instance,
a common control flow is the `match` statement. 

```rust
enum Container {
    Holding(u8, u8),
    Empty,
} 

fn do_something(box: Container) {
    match box {
        Container::Holding(a, b) => (a_u32 + b_u32),
        Container::Empty => println!("oh boy, an empty box!",
    }
}
```

Here's what this code is doing:
- We're declaring a new `enum` called `Container`, that has two variants. 
    The `Holding` variant contains two `u8`, which are just bytes. The `Empty` variant
    doesn't hold anything. 
- Our `do_something` function takes in a `Container`. 
- The `match` statement is kind of like a `switch` statement in other languages. However, 
    instead of matching data to a predicate, it matches data to a predefined pattern. Each
    *arm* in the match statement has a pattern. The first arm executes if `box` is an instance
    of `Container::Holding`, and the pattern defines handles to the two variables that would
    be contained in a `Holding`. The second arm defines the behavior if the `Container` is 
    of variant `Empty`. The nice thing about `match` statements is that they are *exhaustive*, 
    meaning the code won't compile unless we cover all possible cases, or all possible things
    that `box` could be. If we had some pattern that we only need to match a few variants to, we
    can have a default case for all other variants using the `_` placeholder. 

```rust
fn do_something(box: Container) {
    match box {
        Container::Holding(a, b) => (a_u32 + b_u32),
        _ => printf!("This is the default case!"),
    }
}
```

We could also obtain the same control flow using an `if let` statement:
```rust
fn newContainer() -> Container {
    let rand = rand::random();
    if rand {
        Container::Holding(0_u8, 1_u8)
    } else {
        Container::Empty
    }
}

fn do_something {
    if let Container::Holding(a, b) = newContainer() {
        a_u32 + b_u32
    } else {
        printf!("Uh oh, you didn't give us anything!");
    }
}
```

The `if let` statement will execute the true condition if the *expression* on the right
side of the equality matches the pattern on the left side of the equality. 

Pattern matching and `if let` becomes more useful once we understand how `null` values are
handled in Rust. Specifically, there *are no null values in Rust*. Instead, when we have anything
that could either return a value or return nothing, we instead return an `Option` enum. 
```rust
pub enum Option<T> {
    None,
    Some(T),
}
```
This enum can has two variants, `None` which is Rust's version of a non-existent value, or the
`Some(T)` variant that contains a value. The `<T>` notation should be familiar as a *generic*, 
meaning that we can replace `T` with another type when we use `Option<T>` as a return. 

> note: this Option<T> type is a *monad*, which is a construct adopted from functional languages like
> Haskell. This enables pure funcitonal programming following the lambda calculus. 

To reiterate, a primary design pattern in Rust is to return an `Option<T>` whenever we might not
have any value to return. Following this design paradigm, most crates have a lot of functions that
return `Option<T>`s, and we have to handle these explicitly. 
```rust
if let (Some(dp), Some(cp)) = (pac::Peripherals::take(), cortex_m::Peripherals::take(),)
```
This takes us to this line: the body of the if statement only executes if the two functions in the
right side of the equality both return `Some` value. 
- On the left side, we have a `tuple` of two `Some`s. We also define two variables to store the values
    inside the `Some`s, `cp` and `dp`. These will be in scope within the execution block.
- On the right side, we have a `tuple` of `pac::Peripherals`, which provides a handle to the peripherals
    on the microcontroller board, and `cortex_m::Peripherals`, wchich provides a handle to the on-chip
    peripherals. 

If the `if let` statement is valid, we're going to have a scope where we have access to both
the chip peripherals and the board peripherals.


```rust
let gpioa = dp.GPIOA.split();
let mut led = gpioa.pa5.into_push_pull_output();
```
Here, we declare a variable `gpoia`. On our microcontroller, there are 8 GPIO
(General-Purpose Input/Output) busses: GPIOA through GPIOH. On most STM32 Nucleo boards with
a Cortex M4, the microcontroller LED is mapped to PA5, which is Pin 5 on the A bus. 

In the `gpioa` declaration, we're referencing `dp`, which is a struct of all the board peripherals. 
We then reference `GPIOA`, which is a field in the `Peripherals` struct. The `split()` method returns
a `struct` of type `Parts`, which has fields for each pin in the bus, which contain the pointers to 
the indivdual bits in memory that correspond to the pins. 

Next, we declare a `mutable` variable `led` that provides a handle to Pin A5 `gpioa.pa5`. The 
`into_push_pull_output()` function writes to the *mode register (MODER)* for the GPIOA bus, 
setting the mode of the pin as an output. `push_pull` is a circuits concept that I won't get
into here, but all this means is it's a digital output that can change beteween one and zero. 

Each pin has four possible modes:
1. digital input
2. push/pull output
3. alternate function
4. analog
Alternate function is a little more complicated and is controled by the Alternate Function Register. 
I also won't get into that here. Analog turns the pin into an analog input, which requires use of the
ADC. 

We declare the `led` variable using the `mut` keyword, because we want to be able to write out to it.
All Rust variables are *immutable* by default, and we have to explicitly declare when something should
have mutable state. 



```rust
        let rcc = dp.RCC.constrain();
        let clocks = rcc.cfgr.sysclk(48.MHz()).freeze();
```

The `RCC` is the STM32 *Reset and Clock Controller*. This is a control chip that routes clock signals
from the microprocessor to the peripherals. The `constrain()` method converts the raw RCC pointer into
a struct of type `Rcc`, that lets us safely access the functionality of the RCC without screwing things up. 
Once we have the `rcc` variable which is of type `Rcc`, we now have access to the configuration field of the
struct `cfgr`. The `cfgr` field is a struct of type `CFGR`, which has a bunch of functions to interact with 
the RCC. Next, we call the method `sysclck(freq: Hertz)`, which modifies the `cfgr` field to have a clock
speed of 48 Mhz. Finally, we call the `freeze()` method on the `cfgr` field, which locks the clock speed
and applies it to the actual system. This function returns a `struct` of type `Clocks`, which has a bunch
of fields that store the current state of all the clocks on the system. For instance, the `Clocks` struct
has a field called `sysclk`, which now contains the value `Hertz<48000000, 1, 1>`. 

A lot of these functions might seem very convoluted or confusing, with weird . However, this really is 
everything that needs to happen to configure an embedded system. Most of these functions are intended 
for *initial configuration*, and the compiler enforces that these are only called once. For instance, the
`freeze()` method can only be called once, and locks the clock configuration of the system. The `clocks`
variable is the only one that can exist in the program, and its existence implies that `freeze()` has
been called, and that the clocks for the system have been configured. 


```rust
    let mut delay = cp.SYST.delay(&clocks);
```
Next, we declare a mutable handle to a `SysDelay` type. First, we reference the `SYST` field of the 
core peripherals handle. SYST is the System Timer, which we previously set using the `freeze()` function. 
We then call the `delay(self, clocks: &Clocks)` method, which returns a `SysDelay` struct that has the 
implementation for delay. 

The SysDelay struct has the delay method we're looking for: `delay(&mut self, us: MicrosDurationU32)`, which
gets used by an associated function `delay_ms(&mut self, ms: u32)`. According to the documentation, this 
"pauses execution for `ms` milliseconds". 


```rust
loop {
    led.set_high();
    delay.delay_ms(1000_u32);
    led.set_low();
    delay.delay_ms(1000_u32);
}
```
Finally, we get to the main loop. Our system is configured, and we have handles to all of the peripherals we need. 
- The `set_high` method takes a reference to the pin, and sets it to high. 
- The `delay_ms` method gets called on our delay object for 1000ms.
- The `set_high` method gets called on our pin, setting it to low. 
- The `delay_ms` method gets called on our delay object for 1000ms.


Thats it! Thats our whole program. 

Notice how a lot of the work for our short program is *system configuration*. When we work this close to the hardware,
we can't make any assumptions about the state of the machine. However, dealing with safe methods and higher level code is
still a lot better than dealing with raw memory addresses and dereferenced pointers, and it's a lot easier to read
Rust crate documentation than thousands of pages of STM documentation. 
